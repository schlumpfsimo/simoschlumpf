<!doctype html>
<html lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Simo Schlumpf — Kontakt</title>
  <style>
    :root{
      --bg:#ffffff;
      --ink:#000000;
    }
    html,body{height:100%;margin:0;}
    body{
      background:var(--bg);
      color:var(--ink);
      font-family:"Helvetica Neue", Helvetica, Arial, system-ui, sans-serif;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    /* layout */
    .wrap{
      min-height:100%;
      display:grid;
      grid-template-rows: 1fr auto;
    }

    .stage{
      position:relative;
      overflow:hidden;
      display:grid;
      place-items:center;
      padding: clamp(18px, 4vw, 48px);
    }

    /* canvas fills stage */
    canvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
      display:block;
      touch-action:none; /* important for pointer events on mobile */
    }

    /* contact card */
    .card{
      position:relative;
      z-index:2;
      max-width: 42rem;
      width: min(680px, 92vw);
      padding: clamp(14px, 2.4vw, 22px);
      background: rgba(255,255,255,.92);
      backdrop-filter: blur(2px);
    }

    .name{
      font-size: clamp(22px, 3.4vw, 34px);
      font-weight: 600;
      letter-spacing: -0.01em;
      margin:0 0 6px 0;
    }
    .tagline{
      font-size: clamp(14px, 2.1vw, 18px);
      font-weight: 400;
      margin:0 0 16px 0;
    }

    .details{
      font-size: clamp(14px, 2.1vw, 18px);
      line-height: 1.55;
      white-space: pre-line; /* keep line breaks */
      margin:0;
    }

    /* make copyable text the default (no user-select none anywhere) */
    a{ color:inherit; text-decoration:none; border-bottom:1px solid rgba(0,0,0,.25); }
    a:hover{ border-bottom-color: rgba(0,0,0,.6); }

    footer{
      padding: 10px 16px;
      font-size: 12px;
      opacity: .55;
    }
  </style>
</head>

<body>
  <div class="wrap">
    <main class="stage" aria-label="Kontakt">
      <canvas id="map" aria-hidden="true"></canvas>

      <section class="card">
        <h1 class="name">Simo Schlumpf</h1>
        <p class="tagline">Europäische Politik in der Schweiz</p>

        <p class="details">
0041 79 907 56 59
schlumpfsimo [at] gmail.com
        </p>

        <!-- optional: clickable email while keeping the visible text copyable -->
        <p class="details" style="margin-top:10px; opacity:.9;">
          <a href="mailto:schlumpfsimo@gmail.com">Mail öffnen</a>
        </p>
      </section>
    </main>

    <footer>Interactive dotted Europe — follows cursor/finger.</footer>
  </div>

  <script>
    // ------------------------------------------------------------
    // Dotted Europe (vector-seeded → sampled dots → parallax + pull)
    // ------------------------------------------------------------
    const canvas = document.getElementById("map");
    const ctx = canvas.getContext("2d", { alpha: true });

    let W=0, H=0, DPR=1;
    let dots = [];
    let pointer = { x: 0.5, y: 0.5, tx: 0.5, ty: 0.5, down:false };

    // Very lightweight "Europe-ish" silhouette as vector paths.
    // (Mainland + UK/IE + Scandinavia hint + Italy/Spain/GR hint)
    function europePath2D(w, h){
      const p = new Path2D();

      // We draw in normalized coordinates then scale.
      // Mainland (rough envelope)
      const mainland = [
        [0.26,0.34],[0.31,0.27],[0.40,0.23],[0.52,0.24],[0.62,0.28],[0.71,0.36],
        [0.76,0.45],[0.73,0.55],[0.66,0.60],[0.62,0.68],[0.56,0.73],[0.49,0.75],
        [0.43,0.72],[0.37,0.66],[0.33,0.58],[0.28,0.50],[0.25,0.42]
      ];
      poly(p, mainland, w, h);

      // Scandinavia-ish
      const scandi = [
        [0.58,0.18],[0.64,0.14],[0.72,0.16],[0.76,0.22],[0.74,0.30],[0.69,0.32],
        [0.64,0.28],[0.60,0.24]
      ];
      poly(p, scandi, w, h);

      // UK
      const uk = [
        [0.28,0.30],[0.31,0.28],[0.34,0.30],[0.34,0.35],[0.31,0.38],[0.28,0.36]
      ];
      poly(p, uk, w, h);

      // Ireland
      const ie = [
        [0.25,0.33],[0.27,0.32],[0.28,0.34],[0.27,0.36],[0.25,0.35]
      ];
      poly(p, ie, w, h);

      // Iberia
      const iberia = [
        [0.28,0.52],[0.34,0.50],[0.40,0.52],[0.39,0.60],[0.32,0.61],[0.28,0.57]
      ];
      poly(p, iberia, w, h);

      // Italy-ish (boot-ish)
      const italy = [
        [0.48,0.56],[0.52,0.58],[0.54,0.62],[0.52,0.66],[0.50,0.64],[0.49,0.60]
      ];
      poly(p, italy, w, h);

      // Greece-ish
      const gr = [
        [0.56,0.66],[0.60,0.67],[0.62,0.70],[0.58,0.72],[0.55,0.70]
      ];
      poly(p, gr, w, h);

      return p;

      function poly(path, pts, w, h){
        path.moveTo(pts[0][0]*w, pts[0][1]*h);
        for(let i=1;i<pts.length;i++) path.lineTo(pts[i][0]*w, pts[i][1]*h);
        path.closePath();
      }
    }

    function resize(){
      const r = canvas.getBoundingClientRect();
      DPR = Math.min(2, window.devicePixelRatio || 1);
      W = Math.max(1, Math.floor(r.width * DPR));
      H = Math.max(1, Math.floor(r.height * DPR));
      canvas.width = W;
      canvas.height = H;
      buildDots();
    }

    function buildDots(){
      const off = document.createElement("canvas");
      off.width = W;
      off.height = H;
      const octx = off.getContext("2d");

      // Fit the silhouette to canvas with margins
      const margin = Math.floor(Math.min(W,H) * 0.10);
      const boxW = W - margin*2;
      const boxH = H - margin*2;

      // Choose a Europe "frame" that scales well
      const frameW = Math.floor(boxW * 0.78);
      const frameH = Math.floor(boxH * 0.78);
      const ox = Math.floor((W - frameW)/2);
      const oy = Math.floor((H - frameH)/2);

      octx.clearRect(0,0,W,H);
      octx.fillStyle = "#fff";
      octx.fillRect(0,0,W,H);

      octx.save();
      octx.translate(ox, oy);
      // draw filled silhouette in black as sampling mask
      octx.fillStyle = "#000";
      octx.fill(europePath2D(frameW, frameH));
      octx.restore();

      const img = octx.getImageData(0,0,W,H).data;

      dots = [];

      // "More detailed": adaptive step → more dots on larger canvases
      const base = Math.max(2, Math.floor(Math.min(W,H) / 420));
      const step = Math.max(2, Math.floor((3 + base) * DPR)); // smaller step = denser
      for(let y=0; y<H; y+=step){
        for(let x=0; x<W; x+=step){
          const i = (y*W + x)*4;
          const a = img[i+3];
          if(a < 10) continue;

          // mask is black where Europe is filled
          const r = img[i], g = img[i+1], b = img[i+2];
          const lum = 0.2126*r + 0.7152*g + 0.0722*b;
          if(lum < 40){
            const depth = 0.25 + Math.random()*0.75; // parallax depth
            const phase = Math.random()*Math.PI*2;
            dots.push({ x0:x, y0:y, d:depth, p:phase });
          }
        }
      }
    }

    function draw(t){
      const time = t * 0.001;
      ctx.clearRect(0,0,W,H);

      // white page, but give dots subtle spatial feel via density only
      ctx.fillStyle = "#ffffff";
      ctx.fillRect(0,0,W,H);

      // Smooth-follow target
      pointer.x += (pointer.tx - pointer.x) * 0.10;
      pointer.y += (pointer.ty - pointer.y) * 0.10;

      const dx = (pointer.x - 0.5) * 34 * DPR;
      const dy = (pointer.y - 0.5) * 22 * DPR;

      // Local “follow” / attraction around pointer position
      const px = pointer.x * W;
      const py = pointer.y * H;

      // dot style (black on white)
      ctx.fillStyle = "#000000";
      const size = Math.max(1, Math.floor(1.15 * DPR));

      for(const dot of dots){
        // gentle drift
        const driftX = Math.sin(time*0.9 + dot.p) * 0.55 * DPR;
        const driftY = Math.cos(time*0.8 + dot.p) * 0.55 * DPR;

        // parallax
        let x = dot.x0 + dx * dot.d + driftX;
        let y = dot.y0 + dy * dot.d + driftY;

        // pointer “pull” (stronger on touch/press)
        const vx = x - px;
        const vy = y - py;
        const dist2 = vx*vx + vy*vy;
        const radius = (pointer.down ? 220 : 160) * DPR;
        const r2 = radius*radius;

        if(dist2 < r2){
          const dist = Math.max(1, Math.sqrt(dist2));
          const pull = (1 - dist / radius);
          // Move dots slightly toward pointer, but keep stable
          x -= vx * pull * 0.07;
          y -= vy * pull * 0.07;
        }

        ctx.fillRect(x, y, size, size);
      }

      requestAnimationFrame(draw);
    }

    function setPointerFromEvent(e){
      const r = canvas.getBoundingClientRect();
      const cx = (e.clientX - r.left) / Math.max(1, r.width);
      const cy = (e.clientY - r.top) / Math.max(1, r.height);
      pointer.tx = Math.min(1, Math.max(0, cx));
      pointer.ty = Math.min(1, Math.max(0, cy));
    }

    // Pointer events unify mouse + touch
    canvas.addEventListener("pointermove", (e)=> setPointerFromEvent(e), { passive:true });
    canvas.addEventListener("pointerdown", (e)=>{ pointer.down=true; setPointerFromEvent(e); }, { passive:true });
    canvas.addEventListener("pointerup",   ()=>{ pointer.down=false; }, { passive:true });
    canvas.addEventListener("pointercancel",()=>{ pointer.down=false; }, { passive:true });
    window.addEventListener("resize", resize);

    // boot
    resize();
    requestAnimationFrame(draw);
  </script>
</body>
</html>
